{"version":3,"file":"default-src_app_auth_auth_service_ts.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAiG;AACtD;AACD;AACd;AAC6B;;AAEjB;AACxC,wBAAwB,yDAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,mCAAmC,sDAAe;AACjH,uCAAuC,gEAAyB,GAAG,yDAAyD;AAC5H;AACA,MAAM,gCAAgC,MAAM,iDAAM,wBAAwB;AAC1E;AACA,eAAe,mDAAmD,+DAAwB;AAC1F,cAAc,qDAAU;AACxB,KAAK,iBAAiB,UAAU;AAChC,sBAAsB,iDAAM;AAC5B;AACA,aAAa,GAAG,IAAI,UAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB,EAAE;AAClD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW,EAAE,MAAM;AAC7D,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0CAAI,aAAa,wDAAQ;AAC5C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iCAAiC,sDAAe,eAAe,sDAAe,oBAAoB,sDAAe,CAAC,qDAAQ;AACrL,qCAAqC,gEAAyB,GAAG,qDAAqD;AACtH;AACA,MAAM,gCAAgC,MAAM,iDAAM,wBAAwB,GAAG;AAC7E,MAAM,wBAAwB;AAC9B,MAAM,+BAA+B,MAAM,iDAAM,SAAS,qDAAQ,IAAI;AACtE;AACA,eAAe,mDAAmD,+DAAwB;AAC1F,cAAc,qDAAU;AACxB,KAAK,iBAAiB,UAAU;AAChC,sBAAsB,iDAAM;AAC5B;AACA,aAAa,GAAG,IAAI,wBAAwB,IAAI;AAChD,sBAAsB,iDAAM;AAC5B,uBAAuB,qDAAQ;AAC/B,aAAa,GAAG,IAAI,UAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAiB;AAC9C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iDAAiD,4BAA4B,sDAAe;AAC5F,+BAA+B,8DAAuB,GAAG,iBAAiB;AAC1E,+BAA+B,8DAAuB,GAAG;AACzD;AACA,MAAM,gCAAgC,MAAM,mDAAQ,EAAE,IAAI,MAAM,mDAAQ,EAAE;AAC1E;AACA,eAAe,mDAAmD,+DAAwB;AAC1F,cAAc,mDAAQ;AACtB,KAAK,iBAAiB,UAAU;AAChC,sBAAsB,mDAAQ;AAC9B,aAAa;AACb,sBAAsB,mDAAQ;AAC9B,aAAa,GAAG,IAAI,UAAU;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;;AAEoE;;;;;;;;;;;;;;;;;;;;;;;;;;AC3QzB;AACoB;AACtB;AACU;AAEV;AAGkB;AAElB;AACa;IASzC,WAAW,SAAX,WAAW;IAOtB,YAAoB,UAAsB,EACb,OAAe,EACxB,MAAc;QAFd,eAAU,GAAV,UAAU,CAAY;QACb,YAAO,GAAP,OAAO,CAAQ;QACxB,WAAM,GAAN,MAAM,CAAQ;QANlC,cAAS,GAAG,IAAI,gEAAgB,EAAE,CAAC;QACnC,cAAS,GAAG,IAAI,iDAAe,CAAC,KAAK,CAAC,CAAC;IAUvC,CAAC;IAED,mDAAmD;IACnD,wGAAwG;IACxG,yCAAyC;IACzC,wBAAwB;IACxB,yEAAyE;IACzE,qEAAqE;IACrE,uCAAuC;IACvC,UAAU;IACV,SAAS;IAET,OAAO;IACP,IAAI;IAEJ,mBAAmB;IACnB,+CAA+C;IAC/C,6CAA6C;IAC7C,kCAAkC;IAClC,IAAI;IAEJ,iBAAiB;IACjB,4CAA4C;IAC5C,IAAI;IAEJ,MAAM,CAAC,IAAU;QACf,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAO,GAAG,kFAAwB,EAAE,EAAE,IAAI,CAAC,CAAC;IACzE,CAAC;IAED,SAAS,CAAC,QAAQ,EAAE,QAAQ;QAC1B,IAAI,OAAO,GAAG;YACd,OAAO,EAAE,IAAI,6DAAW,EAAE,CAAC,GAAG,CAAC,cAAc,EAAE,mCAAmC,CAAC;SACtF,CAAC;QAEE,IAAI,IAAI,GAAG,IAAI,eAAe,EAAE,CAAC;QACjC,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QAC/B,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QAC/B,IAAI,CAAC,UAAU;aACd,IAAI,CAAC,GAAG,wFAA8B,YAAY,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,OAAO,CAAC;aAC7E,IAAI,CAAC,mDAAG,CAAC,CAAC,QAAa,EAAE,EAAE;YAC1B,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,YAAY;YACnC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC;YACxD,IAAI,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC,uBAAuB;YAC5F,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,YAAY;YAC9C,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC1B,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,YAAY;YACtC,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;aACF,SAAS,CAAC,QAAQ,CAAC,EAAE;YAClB,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC;YACrB,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;IAEL,CAAC;IAED,eAAe;QACb,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC;IAC9B,CAAC;CAOF;;YAjGQ,4DAAU;YAIV,mDAAO;YAKP,mDAAM;;AAUF,WAAW;IAJvB,yDAAU,CAAC;QACV,UAAU,EAAE,MAAM;KAEnB,CAAC;GACW,WAAW,CA8EvB;AA9EuB","sources":["./node_modules/@auth0/angular-jwt/__ivy_ngcc__/fesm2015/auth0-angular-jwt.js","./src/app/auth/auth.service.ts"],"sourcesContent":["import { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { mergeMap } from 'rxjs/operators';\nimport { from } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nimport * as ɵngcc0 from '@angular/core';\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n\n// tslint:disable:no-bitwise\nclass JwtHelperService {\n    constructor(config = null) {\n        this.tokenGetter = (config && config.tokenGetter) || function () { };\n    }\n    urlBase64Decode(str) {\n        let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        switch (output.length % 4) {\n            case 0: {\n                break;\n            }\n            case 2: {\n                output += \"==\";\n                break;\n            }\n            case 3: {\n                output += \"=\";\n                break;\n            }\n            default: {\n                throw new Error(\"Illegal base64url string!\");\n            }\n        }\n        return this.b64DecodeUnicode(output);\n    }\n    // credits for decoder goes to https://github.com/atk\n    b64decode(str) {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        let output = \"\";\n        str = String(str).replace(/=+$/, \"\");\n        if (str.length % 4 === 1) {\n            throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n        }\n        for (\n        // initialize result and counters\n        let bc = 0, bs, buffer, idx = 0; \n        // get next character\n        (buffer = str.charAt(idx++)); \n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n            ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4)\n            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n            : 0) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n        return output;\n    }\n    b64DecodeUnicode(str) {\n        return decodeURIComponent(Array.prototype.map\n            .call(this.b64decode(str), (c) => {\n            return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n            .join(\"\"));\n    }\n    decodeToken(token = this.tokenGetter()) {\n        if (!token || token === \"\") {\n            return null;\n        }\n        const parts = token.split(\".\");\n        if (parts.length !== 3) {\n            throw new Error(\"The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.\");\n        }\n        const decoded = this.urlBase64Decode(parts[1]);\n        if (!decoded) {\n            throw new Error(\"Cannot decode the token.\");\n        }\n        return JSON.parse(decoded);\n    }\n    getTokenExpirationDate(token = this.tokenGetter()) {\n        let decoded;\n        decoded = this.decodeToken(token);\n        if (!decoded || !decoded.hasOwnProperty(\"exp\")) {\n            return null;\n        }\n        const date = new Date(0);\n        date.setUTCSeconds(decoded.exp);\n        return date;\n    }\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n        if (!token || token === \"\") {\n            return true;\n        }\n        const date = this.getTokenExpirationDate(token);\n        offsetSeconds = offsetSeconds || 0;\n        if (date === null) {\n            return false;\n        }\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n    getAuthScheme(authScheme, request) {\n        if (typeof authScheme === \"function\") {\n            return authScheme(request);\n        }\n        return authScheme;\n    }\n}\nJwtHelperService.ɵfac = function JwtHelperService_Factory(t) { return new (t || JwtHelperService)(ɵngcc0.ɵɵinject(JWT_OPTIONS)); };\nJwtHelperService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: JwtHelperService, factory: JwtHelperService.ɵfac });\nJwtHelperService.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JwtHelperService, [{\n        type: Injectable\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [JWT_OPTIONS]\n            }] }]; }, null); })();\n\nclass JwtInterceptor {\n    constructor(config, jwtHelper, document) {\n        this.jwtHelper = jwtHelper;\n        this.document = document;\n        this.standardPorts = [\"80\", \"443\"];\n        this.tokenGetter = config.tokenGetter;\n        this.headerName = config.headerName || \"Authorization\";\n        this.authScheme =\n            config.authScheme || config.authScheme === \"\"\n                ? config.authScheme\n                : \"Bearer \";\n        this.allowedDomains = config.allowedDomains || [];\n        this.disallowedRoutes = config.disallowedRoutes || [];\n        this.throwNoTokenError = config.throwNoTokenError || false;\n        this.skipWhenExpired = config.skipWhenExpired;\n    }\n    isAllowedDomain(request) {\n        const requestUrl = new URL(request.url, this.document.location.origin);\n        // If the host equals the current window origin,\n        // the domain is allowed by default\n        if (requestUrl.host === this.document.location.host) {\n            return true;\n        }\n        // If not the current domain, check the allowed list\n        const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port)\n            ? \":\" + requestUrl.port\n            : \"\"}`;\n        return (this.allowedDomains.findIndex((domain) => typeof domain === \"string\"\n            ? domain === hostName\n            : domain instanceof RegExp\n                ? domain.test(hostName)\n                : false) > -1);\n    }\n    isDisallowedRoute(request) {\n        const requestedUrl = new URL(request.url, this.document.location.origin);\n        return (this.disallowedRoutes.findIndex((route) => {\n            if (typeof route === \"string\") {\n                const parsedRoute = new URL(route, this.document.location.origin);\n                return (parsedRoute.hostname === requestedUrl.hostname &&\n                    parsedRoute.pathname === requestedUrl.pathname);\n            }\n            if (route instanceof RegExp) {\n                return route.test(request.url);\n            }\n            return false;\n        }) > -1);\n    }\n    handleInterception(token, request, next) {\n        const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n        let tokenIsExpired = false;\n        if (!token && this.throwNoTokenError) {\n            throw new Error(\"Could not get token from tokenGetter function.\");\n        }\n        if (this.skipWhenExpired) {\n            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n        }\n        if (token && tokenIsExpired && this.skipWhenExpired) {\n            request = request.clone();\n        }\n        else if (token) {\n            request = request.clone({\n                setHeaders: {\n                    [this.headerName]: `${authScheme}${token}`,\n                },\n            });\n        }\n        return next.handle(request);\n    }\n    intercept(request, next) {\n        if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n            return next.handle(request);\n        }\n        const token = this.tokenGetter(request);\n        if (token instanceof Promise) {\n            return from(token).pipe(mergeMap((asyncToken) => {\n                return this.handleInterception(asyncToken, request, next);\n            }));\n        }\n        else {\n            return this.handleInterception(token, request, next);\n        }\n    }\n}\nJwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) { return new (t || JwtInterceptor)(ɵngcc0.ɵɵinject(JWT_OPTIONS), ɵngcc0.ɵɵinject(JwtHelperService), ɵngcc0.ɵɵinject(DOCUMENT)); };\nJwtInterceptor.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: JwtInterceptor, factory: JwtInterceptor.ɵfac });\nJwtInterceptor.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] },\n    { type: JwtHelperService },\n    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JwtInterceptor, [{\n        type: Injectable\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [JWT_OPTIONS]\n            }] }, { type: JwtHelperService }, { type: Document, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n\nclass JwtModule {\n    constructor(parentModule) {\n        if (parentModule) {\n            throw new Error(\"JwtModule is already loaded. It should only be imported in your application's main module.\");\n        }\n    }\n    static forRoot(options) {\n        return {\n            ngModule: JwtModule,\n            providers: [\n                {\n                    provide: HTTP_INTERCEPTORS,\n                    useClass: JwtInterceptor,\n                    multi: true,\n                },\n                options.jwtOptionsProvider || {\n                    provide: JWT_OPTIONS,\n                    useValue: options.config,\n                },\n                JwtHelperService,\n            ],\n        };\n    }\n}\nJwtModule.ɵfac = function JwtModule_Factory(t) { return new (t || JwtModule)(ɵngcc0.ɵɵinject(JwtModule, 12)); };\nJwtModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: JwtModule });\nJwtModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\nJwtModule.ctorParameters = () => [\n    { type: JwtModule, decorators: [{ type: Optional }, { type: SkipSelf }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JwtModule, [{\n        type: NgModule\n    }], function () { return [{ type: JwtModule, decorators: [{\n                type: Optional\n            }, {\n                type: SkipSelf\n            }] }]; }, null); })();\n\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };\n\n","import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { map, tap } from 'rxjs/operators'\r\nimport { Observable, BehaviorSubject } from 'rxjs';\r\n\r\nimport { Storage } from '@ionic/storage';\r\nimport { User } from './user';\r\nimport { AuthResponse } from './auth-response';\r\nimport { environment } from 'src/environments/environment';\r\nimport { UserConnection } from './user-connection';\r\nimport { Router } from '@angular/router';\r\nimport { JwtHelperService } from \"@auth0/angular-jwt\";\r\n\r\n\r\n\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n\r\n})\r\nexport class AuthService {\r\n\r\n  \r\n  jwtHelper = new JwtHelperService();\r\n  authState = new BehaviorSubject(false);\r\n\r\n\r\n  constructor(private httpClient: HttpClient, \r\n              private readonly storage:Storage, \r\n              private router: Router\r\n\r\n    ) {\r\n   \r\n\r\n  }\r\n\r\n  // register(user: User): Observable<AuthResponse> {\r\n  //   return this.httpClient.post<AuthResponse>(`${environment.AUTH_SERVER_ADRESS}/register`, user).pipe(\r\n  //     tap(async (res: AuthResponse) => {\r\n  //       if (res.user) {\r\n  //         await this.storage.set(\"ACCESS_TOKEN\", res.user.access_token);\r\n  //         await this.storage.set(\"EXPIRES_IN\", res.user.expires_in);\r\n  //         this.authSubject.next(true);\r\n  //       }\r\n  //     })\r\n\r\n  //   );\r\n  // }\r\n\r\n  // async logout() {\r\n  //   await this.storage.remove(\"ACCESS_TOKEN\");\r\n  //   await this.storage.remove(\"EXPIRES_IN\");\r\n  //   this.authSubject.next(false);\r\n  // }\r\n\r\n  // isLoggedIn() {\r\n  //   return this.authSubject.asObservable();\r\n  // }\r\n\r\n  create(user: User): Observable<User> {\r\n    return this.httpClient.post<User>(`${environment.register_uri}`, user);\r\n  }\r\n\r\n  makeLogin(username, password) {\r\n    let options = {\r\n    headers: new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded')\r\n};\r\n\r\n    let body = new URLSearchParams();\r\n    body.set('username', username);\r\n    body.set('password', password);\r\n    this.httpClient\r\n    .post(`${environment.AUTH_SERVER_ADRESS}/api/login`, body.toString(), options)\r\n    .pipe(map((response: any) => {\r\n      console.log(response); // affichage\r\n      this.storage.set('access_token', response.access_token);\r\n      let decodedUser = this.jwtHelper.decodeToken(response.access_token); // affichage en console\r\n      this.authState.next(decodedUser); // affichage\r\n      this.authState.next(true);\r\n      console.log(decodedUser); // affichage\r\n      return true;\r\n    }))\r\n    .subscribe(response => {\r\n        console.log(response)\r\n        this.router.navigate(['/home']);\r\n    });\r\n\r\n  }\r\n\r\n  isAuthenticated() {\r\n    return this.authState.value;\r\n  }\r\n  \r\n \r\n  \r\n\r\n\r\n\r\n}\r\n\r\n\r\n"],"names":[],"sourceRoot":"webpack:///"}